substitutions:
  name: yet-another-smart-vent

globals:
  - id: move_servo_to_position
    type: float
    initial_value: '0'
  - id: servo_distance_to_move
    type: float
    initial_value: '0.01'
  - id: previous_potentiometer_value1
    type: float
    initial_value: '0'
  - id: previous_potentiometer_value2
    type: float
    initial_value: '0'
  - id: previous_potentiometer_value3
    type: float
    initial_value: '0'
  - id: max_closed_position
    type: float
    initial_value: '1'
  - id: max_opened_position
    type: float
    initial_value: '-1'
  - id: closed_position
    type: float
  - id: closed_potentiometer_position
    type: float
  - id: opened_position
    type: float
  - id: opened_potentiometer_position
    type: float
  - id: closed_position_error_tolerance
    type: float
    initial_value: '0.0015'
  - id: opened_position_error_tolerance
    type: float
    initial_value: '0.001'

esp8266:
  board: d1_mini

esphome:
  name: $name
  on_boot:
    priority: -100
    then:
    - delay: 5s
    - servo.write:
        id: vent_servo
        level: !lambda 'return id(move_servo_to_position);'
    - delay: 1s
    - while:
        condition:
          lambda: 'return id(move_servo_to_position) < id(max_closed_position);'
        then:
          - servo.write:
              id: vent_servo
              level: !lambda 'return id(move_servo_to_position);'
          - delay: 50ms
          - globals.set:
              id: move_servo_to_position
              value: !lambda 'return id(move_servo_to_position) + id(servo_distance_to_move);'
          - globals.set:
              id: previous_potentiometer_value3
              value: !lambda 'return id(previous_potentiometer_value2);'
          - globals.set:
              id: previous_potentiometer_value2
              value: !lambda 'return id(previous_potentiometer_value1);'
          - globals.set:
              id: previous_potentiometer_value1
              value: !lambda 'return id(vent_servo_potentiometer).sample();'
          - if:
              condition:
                lambda: |-
                    const float current_position = id(previous_potentiometer_value1);
                    const float upper_tolerance1 = id(previous_potentiometer_value2) + id(closed_position_error_tolerance);
                    const float lower_tolerance1 = id(previous_potentiometer_value2) - id(closed_position_error_tolerance);
                    const float upper_tolerance2 = id(previous_potentiometer_value3) + id(closed_position_error_tolerance);
                    const float lower_tolerance2 = id(previous_potentiometer_value3) - id(closed_position_error_tolerance);
                    return current_position >= lower_tolerance1 && current_position <= upper_tolerance1
                      && current_position >= lower_tolerance2 && current_position <= upper_tolerance2;
              then: 
                - globals.set:
                    id: max_closed_position
                    value: !lambda 'return id(move_servo_to_position);'
                - globals.set:
                    id: closed_position
                    value: !lambda 'return id(move_servo_to_position);'
                - globals.set:
                    id: closed_potentiometer_position
                    value: !lambda 'return id(previous_potentiometer_value1);'
    - globals.set:
        id: move_servo_to_position
        value: '0'
    - globals.set:
        id: previous_potentiometer_value3
        value: '0'
    - globals.set:
        id: previous_potentiometer_value2
        value: '0'
    - globals.set:
        id: previous_potentiometer_value1
        value: '0'
    - servo.write:
        id: vent_servo
        level: !lambda 'return id(move_servo_to_position);'
    - delay: 200ms
    - while:
        condition:
          lambda: 'return id(move_servo_to_position) > id(max_opened_position);'
        then:
          - servo.write:
              id: vent_servo
              level: !lambda 'return id(move_servo_to_position);'
          - delay: 50ms
          - globals.set:
              id: move_servo_to_position
              value: !lambda 'return id(move_servo_to_position) - id(servo_distance_to_move);'
          - globals.set:
              id: previous_potentiometer_value3
              value: !lambda 'return id(previous_potentiometer_value2);'
          - globals.set:
              id: previous_potentiometer_value2
              value: !lambda 'return id(previous_potentiometer_value1);'
          - globals.set:
              id: previous_potentiometer_value1
              value: !lambda 'return id(vent_servo_potentiometer).sample();'
          - if:
              condition:
                lambda: |-
                    const float current_position = id(previous_potentiometer_value1);
                    const float upper_tolerance1 = id(previous_potentiometer_value2) + id(opened_position_error_tolerance);
                    const float lower_tolerance1 = id(previous_potentiometer_value2) - id(opened_position_error_tolerance);
                    const float upper_tolerance2 = id(previous_potentiometer_value3) + id(opened_position_error_tolerance);
                    const float lower_tolerance2 = id(previous_potentiometer_value3) - id(opened_position_error_tolerance);
                    return current_position >= lower_tolerance1 && current_position <= upper_tolerance1
                      && current_position >= lower_tolerance2 && current_position <= upper_tolerance2;
              then: 
                - globals.set:
                    id: max_opened_position
                    value: !lambda 'return id(move_servo_to_position);'
                - globals.set:
                    id: opened_position
                    value: !lambda 'return id(move_servo_to_position);'
                - globals.set:
                    id: opened_potentiometer_position
                    value: !lambda 'return id(previous_potentiometer_value1);'
    - servo.detach: vent_servo

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: !secret development_static_ip
    gateway: !secret gateway
    subnet: !secret subnet
#  ap:
#    ssid: $upper_name
    
# mqtt:
#   broker: !secret mqtt_broker
#   username: !secret mqtt_username
#   password: !secret mqtt_password

cover:
  - platform: template
    device_class: damper
    id: vent
    name: Vent
    open_action:
      - servo.write:
          id: vent_servo
          level: !lambda 'return id(opened_position);'
    close_action:
      - servo.write:
          id: vent_servo
          level: !lambda 'return id(closed_position);'
    stop_action:
      - servo.write:
          id: vent_servo
          level: !lambda 'return remap(id(vent_servo_potentiometer).state, id(opened_potentiometer_position), id(closed_potentiometer_position), id(opened_position), id(closed_position));'
    lambda: |-
      const float current_position = id(vent_servo_potentiometer).state;
      const float closed_position = id(closed_potentiometer_position);
      const float tolerance = 0.015;
      const float upper_tolerance = closed_position + tolerance;
      const float lower_tolerance = closed_position - tolerance;
      if (current_position >= lower_tolerance && current_position <= upper_tolerance) {
        return COVER_CLOSED;
      }
      return COVER_OPEN;

sensor:
  - platform: adc
    id: vent_servo_potentiometer
    pin: A0
    update_interval: 250ms

servo:
  - id: vent_servo
    output: vent_servo_output
    transition_length: 3s
    auto_detach_time: 200ms

output:
  - platform: esp8266_pwm
    id: vent_servo_output
    pin: D3
    frequency: 50 Hz

web_server:

api:
    
ota:

logger:
  level: DEBUG
